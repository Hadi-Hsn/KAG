<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDF Viewer with Highlighting</title>

    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #f5f5f5;
        overflow-x: hidden;
      }

      #pdf-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        min-height: 100vh;
      }

      .pdf-page-wrapper {
        position: relative;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        background: white;
      }

      canvas {
        display: block;
        max-width: 100%;
        height: auto;
      }

      .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        opacity: 0.2;
        line-height: 1;
      }

      .textLayer > span {
        color: transparent;
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
      }

      /* Highlight styles */
      .textLayer .highlight {
        background-color: rgba(255, 255, 0, 1) !important;
        color: transparent !important;
        box-shadow: 0 0 0 1px rgba(255, 193, 7, 0.5);
        border-radius: 2px;
        transition: background-color 0.2s ease;
      }

      .textLayer .highlight:hover {
        background-color: rgba(255, 255, 0, 0.7) !important;
      }

      /* Loading indicator */
      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px 50px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        font-size: 18px;
        font-weight: 600;
        color: #333;
        z-index: 1000;
      }

      #loading.hidden {
        display: none;
      }

      /* Page number indicator */
      .page-number {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading PDF...</div>
    <div id="pdf-container"></div>

    <script>
      // Configure PDF.js worker
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      // Global variables
      let pdfDoc = null;
      let currentHighlightText = null;
      let renderedPages = new Map(); // Track rendered pages and their text content
      let highlightedElements = []; // Track all highlighted elements for cleanup

      /**
       * Create regex pattern from search text for flexible matching
       */
      function createSearchPattern(searchText) {
        // Clean and split into words (3+ chars for better matching)
        const words = searchText
          .toLowerCase()
          .split(/\s+/)
          .filter((w) => w.length >= 3)
          .map((w) => w.replace(/[.*+?^${}()|[\]\\]/g, "\\\\$&"));

        if (words.length === 0) return null;

        // Create pattern: words separated by flexible spacing/punctuation
        const pattern = words.join("\\\\s*[\\\\s\\\\W]*\\\\s*");
        return new RegExp(pattern, "gi");
      }

      /**
       * Highlight text in text layer using direct span matching
       */
      function highlightTextInLayer(textLayer, textContent, searchText) {
        if (!searchText || searchText.trim().length === 0) {
          return 0;
        }

        const spans = textLayer.querySelectorAll("span");

        // Extract significant words (4+ characters, excluding common words)
        const commonWords = new Set([
          "that",
          "this",
          "with",
          "from",
          "have",
          "been",
          "were",
          "their",
          "there",
          "which",
          "these",
          "those",
          "when",
          "where",
          "what",
          "would",
          "could",
          "should",
        ]);
        const searchWords = searchText
          .toLowerCase()
          .replace(/[^\w\s]/g, " ")
          .split(/\s+/)
          .filter((w) => w.length >= 4 && !commonWords.has(w));

        if (searchWords.length === 0) return 0;

        let highlightCount = 0;
        const matchedSpans = new Set();

        // Build sliding window of text to find phrase matches
        const windowSize = Math.min(searchWords.length * 3, 20); // Reasonable window

        for (let i = 0; i < spans.length; i++) {
          // Get text window around current position
          const windowStart = Math.max(0, i - Math.floor(windowSize / 2));
          const windowEnd = Math.min(
            spans.length,
            i + Math.ceil(windowSize / 2)
          );

          const windowText = Array.from(spans)
            .slice(windowStart, windowEnd)
            .map((s) => s.textContent)
            .join(" ")
            .toLowerCase()
            .replace(/[^\w\s]/g, " ");

          // Check if this window contains most of our search words
          const wordsFound = searchWords.filter((word) =>
            windowText.includes(word)
          );

          // If we found at least 60% of search words in this window
          if (wordsFound.length >= Math.max(1, searchWords.length * 0.6)) {
            const spanText = (spans[i].textContent || "")
              .toLowerCase()
              .replace(/[^\w\s]/g, " ");

            // Only highlight this specific span if it contains a search word
            if (searchWords.some((word) => spanText.includes(word))) {
              matchedSpans.add(i);
            }
          }
        }

        // Apply highlights
        matchedSpans.forEach((idx) => {
          if (idx < spans.length) {
            spans[idx].classList.add("highlight");
            highlightedElements.push(spans[idx]);
            highlightCount++;
          }
        });

        return highlightCount;
      }

      /**
       * Clear all highlights
       */
      function clearHighlights() {
        highlightedElements.forEach((element) => {
          element.classList.remove("highlight");
        });
        highlightedElements = [];
      }

      /**
       * Render a single page
       */
      async function renderPage(pageNum) {
        try {
          const page = await pdfDoc.getPage(pageNum);
          const viewport = page.getViewport({ scale: 1.5 });

          // Create wrapper
          const wrapper = document.createElement("div");
          wrapper.className = "pdf-page-wrapper";
          wrapper.setAttribute("data-page-number", pageNum);

          // Create canvas
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          // Render PDF page to canvas
          await page.render({
            canvasContext: context,
            viewport: viewport,
          }).promise;

          wrapper.appendChild(canvas);

          // Create text layer
          const textLayerDiv = document.createElement("div");
          textLayerDiv.className = "textLayer";
          textLayerDiv.style.width = canvas.width + "px";
          textLayerDiv.style.height = canvas.height + "px";

          // Get text content
          const textContent = await page.getTextContent();

          // Render text layer
          pdfjsLib.renderTextLayer({
            textContent: textContent,
            container: textLayerDiv,
            viewport: viewport,
            textDivs: [],
          });

          wrapper.appendChild(textLayerDiv);

          // Add page number indicator
          const pageIndicator = document.createElement("div");
          pageIndicator.className = "page-number";
          pageIndicator.textContent = `Page ${pageNum}`;
          wrapper.appendChild(pageIndicator);

          // Store page data
          renderedPages.set(pageNum, {
            wrapper: wrapper,
            textLayer: textLayerDiv,
            textContent: textContent,
          });

          return wrapper;
        } catch (error) {
          console.error(`Error rendering page ${pageNum}:`, error);
          return null;
        }
      }

      /**
       * Load and render PDF
       */
      async function loadPDF(url, pageNumber = null) {
        try {
          // Show loading
          document.getElementById("loading").classList.remove("hidden");

          // Load PDF
          const loadingTask = pdfjsLib.getDocument(url);
          pdfDoc = await loadingTask.promise;

          const container = document.getElementById("pdf-container");
          container.innerHTML = "";

          // Determine which page to load first
          const targetPage =
            pageNumber && pageNumber > 0 && pageNumber <= pdfDoc.numPages
              ? pageNumber
              : 1;

          // Render target page first for faster initial display
          const targetPageWrapper = await renderPage(targetPage);
          if (targetPageWrapper) {
            container.appendChild(targetPageWrapper);
          }

          // Render other pages
          for (let i = 1; i <= pdfDoc.numPages; i++) {
            if (i === targetPage) continue; // Already rendered

            const wrapper = await renderPage(i);
            if (wrapper) {
              if (i < targetPage) {
                container.insertBefore(wrapper, targetPageWrapper);
              } else {
                container.appendChild(wrapper);
              }
            }
          }

          // Hide loading
          document.getElementById("loading").classList.add("hidden");

          // Scroll to target page if specified
          if (pageNumber) {
            setTimeout(() => {
              const pageWrapper = container.querySelector(
                `[data-page-number="${pageNumber}"]`
              );
              if (pageWrapper) {
                pageWrapper.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });
              }
            }, 300);
          }

          return true;
        } catch (error) {
          console.error("Error loading PDF:", error);
          document.getElementById("loading").textContent = "Error loading PDF";
          return false;
        }
      }

      /**
       * Highlight text across all pages
       */
      function highlightText(searchText) {
        // Clear previous highlights
        clearHighlights();
        currentHighlightText = searchText;

        if (!searchText || searchText.trim().length === 0) {
          return;
        }

        let totalHighlights = 0;
        let firstHighlightPage = null;

        // Highlight in all rendered pages
        renderedPages.forEach((pageData, pageNum) => {
          const count = highlightTextInLayer(
            pageData.textLayer,
            pageData.textContent,
            searchText
          );

          if (count > 0) {
            totalHighlights += count;
            if (firstHighlightPage === null) {
              firstHighlightPage = pageNum;
            }
          }
        });

        if (totalHighlights === 0) {
          // Text not found
        } else {
          // Scroll to first highlight
          if (firstHighlightPage) {
            setTimeout(() => {
              const pageWrapper = document.querySelector(
                `[data-page-number="${firstHighlightPage}"]`
              );
              if (pageWrapper) {
                // Scroll to top of page, not center
                pageWrapper.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });

                // Fine-tune scroll position - scroll up a bit to show page top
                setTimeout(() => {
                  window.scrollBy({
                    top: -80,
                    behavior: "smooth",
                  });
                }, 400);
              }
            }, 300);
          }
        }
      }

      /**
       * Parse URL parameters
       */
      function getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        return {
          file: params.get("file"),
          page: params.get("page") ? parseInt(params.get("page")) : null,
        };
      }

      /**
       * Listen for messages from parent window
       */
      window.addEventListener("message", async (event) => {
        const { type, data } = event.data;

        switch (type) {
          case "HIGHLIGHT_TEXT":
            highlightText(data.text);
            break;

          case "CLEAR_HIGHLIGHTS":
            clearHighlights();
            break;

          case "LOAD_PDF":
            await loadPDF(data.url, data.page);
            break;
        }
      });

      /**
       * Initialize viewer
       */
      async function init() {
        const params = getUrlParams();

        if (params.file) {
          // Decode the file URL
          const pdfUrl = decodeURIComponent(params.file);
          await loadPDF(pdfUrl, params.page);
        } else {
          document.getElementById("loading").textContent = "No PDF specified";
        }
      }

      // Start initialization when DOM is ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    </script>
  </body>
</html>
